<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>work board</title>
    <script src="https://kit.fontawesome.com/289a62abf7.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <style>
        .mainW {
            position: absolute;
            top: 0%;
            left: 50%;
            transform: translate(-50%, 0%);
            margin-top: 100px;

            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
        }
        
        .worklist_box {
            display: flex;
            flex-direction: column;
            border: none;
            height: 100%; /* 원본 스타일 유지 */
            max-height: 80vh;
            width: 250px; /* 원본 스타일 유지 - 실제 상세 영역은 인라인으로 700px 적용 */
            border-radius: 10px;
            background-color: white;
            box-shadow : 0px 0px 3px rgba(0, 0, 0, 0.1); /* 원본 스타일 유지 */
            overflow: hidden;
        }

        .worklist_box2 {
            border: none;
            height: 100%; /* 원본 스타일 유지 */
            max-height: 80vh; /* 원본 스타일 유지 */
            width: 250px; /* 원본 스타일 유지 */
            border-radius: 10px;
            background-color: white;
            box-shadow : 0px 0px 3px rgba(0, 0, 0, 0.1); /* 원본 스타일 유지 */
            overflow-y: scroll; /* 원본 스타일 유지 */
        }
        .worklist_box2::-webkit-scrollbar{
            display: none;
        }

        .button_work {
            background-color: transparent;
            border: solid 1px rgb(112, 165, 139);            
            height:25px;
            width:50px;
            color:rgb(112, 165, 139);
            font-size: 15px;
            font-weight: 500;
            border-radius: 4px;
            font-family: 'Pretendard-Regular';
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .button_work:hover {
            background-color: rgba(112, 165, 139, 0.05);
        }
        .button_work2 { /* 댓글 등록 버튼 */
            background-color:rgb(255, 255, 255);
            border: none;
            height:25px;
            width:50px; /* '등록' 글씨에 맞게 조정 또는 auto */
            min-width: 50px;
            padding: 0 10px;
            box-shadow : 0px 0px 2px rgba(150, 150, 150, 0.8);
            color:rgb(10, 10, 10);
            font-size: 14px; 
            font-weight: 500;
            border-radius: 4px;
            font-family: 'Pretendard-Regular';
            cursor: pointer;
        }

        .comment_box { 
            border: 1px solid gray; /* 원본 스타일 유지 */
            background-color: rgb(235, 235, 235); 
            width: 100%;
            padding: 10px;
            border-radius: 10px;
            border: none; /* 원본 스타일 유지 */
            box-sizing: border-box;
        }
        .comment_box input[type="text"] { /* 원본 스타일 유지 */
            font-size: small; 
            border: none; 
            background-color: transparent; 
            outline: none; 
            width:500px; /* 원본 스타일 유지 */
        }
        .comment_box textarea { /* 댓글 입력 textarea */
            font-size: 13px; 
            border: 1px solid #ddd; 
            background-color: white; 
            outline: none; 
            width:100%; 
            min-height:60px;
            padding:8px;
            border-radius:4px;
            box-sizing:border-box; 
            resize:vertical;
        }


        .mainW table {
            border-collapse: collapse;
            width: 100%;
        }
        .mainW th, .mainW td { 
            padding: 15px; /* 원본 스타일 유지 */
            border-bottom: 1px solid rgb(230, 230, 230);
            text-align: left;
        }
         .mainW table tbody tr:hover td { 
            background-color: #f0f0f0; 
        }
        
        .high_box{ 
            height: 50px; /* 원본 스타일 유지 */
            padding: 10px; /* 원본 스타일 유지 */
            display: flex;
            flex-direction: row;
            align-items:center;
        }

        .button_done{ /* "돌아가기" 버튼 */
            height: 50px;
            width: 250px; /* 원본 스타일 유지 */
            margin-top:20px;
            border-radius: 20px;
            border: none;
            background-color: rgb(112, 165, 139);
            box-shadow : 0px 0px 3px rgba(0, 0, 0, 0.2);
            color:rgb(255, 255, 255);
            font-size: 15px;
            font-weight: 500;
            font-family: 'Pretendard-Regular';
            display: flex;
            justify-content:center;
            align-items: center;
            cursor: pointer;
        }
        .button_done:hover {
            background-color: rgb(84, 133, 129);
        }
        
        .box_text { 
            display: flex;
            flex-direction: row;
            width: 100%;
            height: auto; 
            min-height: 130px; /* 원본 스타일 유지 */
            padding: 10px;
            background-color: rgb(240, 240, 240); 
            border-radius: 5px;
            gap: 5px; /* 원본 스타일 유지 */
            white-space: pre-wrap; 
            word-break: break-all; 
            box-sizing: border-box;
            overflow-y: auto; 
            max-height: 300px; 
        }
        .commentlist-item { 
            padding-bottom: 8px;
            margin-bottom: 8px;
            border-bottom: 1px solid rgb(235, 235, 235);
        }
        .commentlist-item-re {
            padding-bottom: 8px;
            margin-bottom: 8px;;
            border-bottom: 1px solid rgb(245, 245, 245);
            background-color: white;
        }
        .replyArea{
            margin-top: 10px;
            padding-left: 10px;
            background-color: rgb(247, 247, 247);
        }
    </style>
  <script type="module" crossorigin src="/assets/approot-lCmlQQZV.js"></script>
  <link rel="stylesheet" crossorigin href="/css/bootstrap.CyjhP-aL.css">
  <link rel="stylesheet" crossorigin href="/css/styles.fgilQ3_N.css">
</head>
<body style="background-color: rgb(245, 245, 245);">
    <div id="root"></div>

    <div class="mainW">
        <div style="display: flex; gap: 20px;">
            
           
            <div class="worklist_box" style="width: 700px; flex-direction: column;" id="workbox">
                <div class="high_box" style="margin: 15px;">
                    
                    <span id="wlb_taskName" style="position: relative; font-size: 35px; color:rgb(0, 0, 0);">업무명</span>
                    
                    <button id="wlb_writePostBtn" class="button_work" style="width: 100px; height: 40px; margin-left: auto; font-size: medium;">게시글 작성</button>
                </div>
                <hr style="margin: 0;">
                <div class="box_scroll" style="padding: 15px;"> 
                   
                    <div id="wlb_postTitle" style="font-weight: bold; font-size:25px; padding: 10px;">게시글을 선택해주세요.</div>
                    
                    <div id="wlb_postMeta" style="display: flex; flex-direction: row; align-items: flex-end; padding: 0 10px 10px 10px;">
                       
                    </div> 
                    <hr style="border: none; border-bottom: 1px solid rgb(160, 160, 160); margin: 0;" />
                    <div style="padding:10px;">
                        
                        <div id="wlb_postFiles" style="display: flex; flex-direction: column; justify-content: flex-start; align-items: flex-end; min-height:20px;">
                            
                        </div>
                        
                        <div style="height:300px;"> 
                            <div id="wlb_postContent" style="font-weight: 400; height:100%; overflow-y:auto; white-space:pre-wrap; word-break:break-all;">
                                
                            </div>
                        </div>
                    </div>
                    <div id="wlb_postActionButtons" style="display: none; justify-content: flex-end; align-items: center; margin-top:5px; padding: 0 10px; gap:5px;"> 
                        <button id="wlb_editPostBtn" class="button_work">수정</button>
                        <button id="wlb_deletePostBtn" class="button_work" style="border-color:rgb(173, 98, 98); color:rgb(173, 98, 98)">삭제</button>
                    </div>
                    <div style="width:100%; margin-top:10px;"> 
                        <hr style="border-top: 1px solid rgb(160, 160, 160);" /> 
                    </div>

                    <div style="margin: 0 10px 10px 10px;">
                        
                        <div class="comment_box">
                            <div style="font-size: medium;">나</div>
                            <textarea id="mainCommentContent" placeholder="댓글 작성하기"></textarea> 
                            <div style="margin-top: 8px; margin-bottom: 8px;">
                                <label for="mainCommentFileUploadInput" style="font-size: 0.85em; color: #555; cursor:pointer;">
                                    <img src="/icon/link.png" style="height:18px; width:18px; vertical-align: middle; margin-right: 3px;"/>
                                    파일 첨부 (개당 10MB 이하)
                                </label>
                                <input type="file" id="mainCommentFileUploadInput" multiple accept="*/*" style="display: none;"/>
                                <div id="selectedMainCommentFilesList" style="font-size: 0.8em; color: #333; margin-top: 5px;">
                                </div>
                            </div>
                            <div style="width:100%;">
                                <hr style="border-top: 1px solid rgb(220, 220, 220); margin: 8px 0;" />
                            </div>
                            <div style="display: flex; justify-content: flex-end; align-items: center;">
                                <button class="button_work2" style="width:70px;" onclick="addCommentHandler()">등록</button>
                            </div>
                        </div>

                        <div style="font-weight:bold; font-size:16px; margin-bottom:10px; margin-top:10px;">댓글 <span id="comcount">0</span>개</div>

                        <div id="commentlist" style="margin-bottom:15px;">
                        </div>

                    </div>                            
                </div>     
                </div>

            
            <div style="display: flex; flex-direction: column;">
                <div class="worklist_box2" style="height: 500px;">
                    <div style="position: sticky; top: 0; background-color:white; z-index:1;">
                        <div style="display: flex; background-color: white; padding: 15px;">
                            <div style="font-weight: bold; font-size:15px;">글 목록</div>                             
                        </div>   
                        <hr style="border-top: 1px solid rgb(220, 220, 220); margin: 0;" />                  
                    </div> 
                    <div class="box_scroll" style="height: calc(100% - 51px);">
                        <table class="table table-hover">
                            
                            <tbody id="wlb_postListTbody">
                                
                            </tbody>
                        </table>                         
                    </div>
                </div>
                
                <div id="wlb_goBackBtn" class="button_done">
                    <span>돌아가기</span>
                </div>
            </div>
        </div>
    </div>
</body>
<script>
    // 전역 변수 선언 (이전과 동일)
    let currentWlbTaskId = null;
    let currentWlbProjectId = null;
    let currentSelectedPostId = null;
    let currentSelectedPostData = null;

    document.addEventListener('DOMContentLoaded', function () {
        const urlParams = new URLSearchParams(window.location.search);
        currentWlbTaskId = parseInt(urlParams.get('taskId'), 10);
        currentWlbProjectId = parseInt(urlParams.get('projectId'), 10);
        const postIdFromUrl = urlParams.get('postId') ? parseInt(urlParams.get('postId'), 10) : null;

        console.log("WorklistBoard Loaded. TaskID:", currentWlbTaskId, "ProjectID:", currentWlbProjectId, "PostID from URL:", postIdFromUrl);

        if (!isNaN(currentWlbTaskId) && !isNaN(currentWlbProjectId)) {
            initializeWorklistBoard(currentWlbTaskId, currentWlbProjectId, postIdFromUrl);
        } else {
            console.error("Task ID or Project ID not found in URL or is invalid.");
            const mainWDiv = document.querySelector('.mainW');
            if (mainWDiv) mainWDiv.innerHTML = '<p style="color:red; text-align:center; padding: 20px;">업무 또는 프로젝트 정보를 불러올 수 없습니다. (URL 파라미터 누락)</p>';
        }

        // 메인 댓글 파일 입력 UI 설정
        const mainCommentFileInput = document.getElementById('mainCommentFileUploadInput');
        const selectedMainCommentFilesListDiv = document.getElementById('selectedMainCommentFilesList');
        const mainCommentFileLabel = document.querySelector('label[for="mainCommentFileUploadInput"]');

        if (mainCommentFileLabel && mainCommentFileInput) {
            // 수정: label의 for 속성으로 충분하므로, 명시적인 click() 호출 제거
            // mainCommentFileLabel.onclick = function() {
            //     mainCommentFileInput.click(); 
            // }; 
            mainCommentFileInput.addEventListener('change', function() {
                displaySelectedFiles(this.files, selectedMainCommentFilesListDiv, 'main_comment_file_');
            });
        }
        
        // 페이지 로드 시 댓글 입력창 비활성화 (게시글 선택 전)
        toggleCommentForm(false); 
    });

    /**
     * 메인 댓글 입력 폼의 활성화/비활성화 상태를 토글합니다.
     */
     function toggleCommentForm(enable) {
        console.log(`[DEBUG] toggleCommentForm called with enable: ${enable}. Current postId: ${currentSelectedPostId}`);
        const commentTextarea = document.getElementById('mainCommentContent');
        const commentFileLabel = document.querySelector('label[for="mainCommentFileUploadInput"]');
        const commentSubmitButton = document.querySelector('.comment_box .button_work2'); // 댓글 등록 버튼

        if (commentTextarea) {
            commentTextarea.disabled = !enable;
            console.log(`[DEBUG] commentTextarea.disabled set to: ${commentTextarea.disabled}`);
        } else {
            console.error("[DEBUG] commentTextarea not found in toggleCommentForm");
        }

        if (commentFileLabel) {
            commentFileLabel.style.pointerEvents = enable ? 'auto' : 'none';
            commentFileLabel.style.opacity = enable ? '1' : '0.5';
            console.log(`[DEBUG] commentFileLabel pointerEvents: ${commentFileLabel.style.pointerEvents}, opacity: ${commentFileLabel.style.opacity}`);
        } else {
            console.error("[DEBUG] commentFileLabel not found in toggleCommentForm");
        }

        if (commentSubmitButton) {
            commentSubmitButton.disabled = !enable;
            console.log(`[DEBUG] commentSubmitButton.disabled set to: ${commentSubmitButton.disabled}`);
        } else {
            console.error("[DEBUG] commentSubmitButton not found in toggleCommentForm");
        }
    }


    async function initializeWorklistBoard(taskId, projectId, postIdToSelect) {
        await loadTaskDetailsForBoard(taskId);
        await loadPostsForBoard(taskId, postIdToSelect);
        updateWorklistBoardButtonLinks(taskId, projectId);

        const writePostBtn = document.getElementById('wlb_writePostBtn');
        if (writePostBtn) {
            writePostBtn.onclick = () => {
                window.location.href = `writework.html?taskId=${currentWlbTaskId}&projectId=${currentWlbProjectId}`;
            };
        }
        const goBackBtn = document.getElementById('wlb_goBackBtn');
        if (goBackBtn) {
            goBackBtn.onclick = () => {
                window.location.href = `projectboard.html?projectId=${currentWlbProjectId}`;
            };
        }
    }
    
    function displaySelectedFiles(files, listContainer, idPrefix = 'file_') {
        // ... (이전 답변과 동일한 함수 내용) ...
        listContainer.innerHTML = '';
        if (files.length > 0) {
            const ul = document.createElement('ul');
            ul.style.cssText = 'padding-left: 0px; list-style-type: none; margin-top: 5px;';
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const li = document.createElement('li');
                li.id = `${idPrefix}${i}`;
                const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
                li.textContent = `${file.name} (${fileSizeMB} MB)`;
                if (file.size > 10 * 1024 * 1024) {
                    li.style.color = 'red';
                    li.textContent += ' - 크기 초과! (업로드 제외)';
                }
                ul.appendChild(li);
            }
            listContainer.appendChild(ul);
        }
    }

    async function loadTaskDetailsForBoard(taskId) {
        // ... (이전 답변과 동일한 함수 내용) ...
        const taskNameEl = document.getElementById('wlb_taskName'); 
        if (!taskNameEl) { console.error("Element #wlb_taskName not found."); return; }
        taskNameEl.textContent = '업무명 로딩 중...';
        try {
            const response = await fetch(`/api/tasks/${taskId}`);
            if (!response.ok) {
                if (response.status === 401) { window.location.href = "/front/login.html"; return; }
                const errorData = await response.json().catch(() => ({message: "업무 이름을 가져오지 못했습니다."}));
                throw new Error(errorData.message || `Failed to fetch task name: ${response.status}`);
            }
            const result = await response.json();
            if (result.status === 200 && result.data) {
                taskNameEl.textContent = result.data.title || '업무명 없음';
            } else {
                taskNameEl.textContent = '업무명 로드 실패';
            }
        } catch (error) {
            console.error("Error loading task name:", error);
            taskNameEl.textContent = '업무명 로드 오류';
        }
    }

    async function loadPostsForBoard(taskId, postIdToSelect = null) {
        // ... (이전 답변과 동일한 함수 내용) ...
        const postListTbodyEl = document.getElementById('wlb_postListTbody'); 
        if (!postListTbodyEl) { console.error("Element #wlb_postListTbody for post list not found."); return; }
        
        postListTbodyEl.innerHTML = '<tr><td colspan="1" style="text-align:center; color:grey; padding:15px;">게시글 목록 로딩 중...</td></tr>';
        if (!postIdToSelect) { // postIdToSelect가 없으면, 즉 URL에 postId가 없거나 목록 처음 로드 시
            clearPostDetailArea(true, "게시글을 선택해주세요."); // currentSelectedPostId = null로 설정됨
            toggleCommentForm(false); // 댓글 폼 비활성화
        }

        try {
            const response = await fetch(`/api/tasks/${taskId}/posts`);
            if (!response.ok) {
                if (response.status === 401) { window.location.href = "/front/login.html"; return; }
                const errorData = await response.json().catch(() => ({ message: `서버 응답 오류: ${response.status}` }));
                throw new Error(errorData.message || `Failed to fetch posts: ${response.status}`);
            }
            const result = await response.json(); 

            postListTbodyEl.innerHTML = ''; 
            if (result.status === 200 && Array.isArray(result.data)) {
                if (result.data.length === 0) {
                    postListTbodyEl.innerHTML = '<tr><td colspan="1" style="text-align:center; color:grey; padding:15px;">이 업무에는 게시글이 없습니다.</td></tr>';
                    clearPostDetailArea(true, "표시할 게시글이 없습니다.");
                    toggleCommentForm(false); // 댓글 폼 비활성화
                } else {
                    let postToDisplayAutomatically = postIdToSelect;
                    if (!postIdToSelect) {
                        postToDisplayAutomatically = result.data[0].idx;
                    }
                    
                    let foundPostIdInList = false;
                    result.data.forEach((post) => {
                        const tr = document.createElement('tr');
                        tr.style.cursor = 'pointer';
                        const postDate = new Date(post.createdAt).toLocaleDateString('ko-KR', { year: 'numeric', month: '2-digit', day: '2-digit'});
                        tr.innerHTML = `<td title="${post.title}\n작성자: ${post.authorNickname}\n작성일: ${postDate}">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <span style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; font-size:13px;">${post.title || '제목 없음'}</span>
                                                <span style="font-size: 0.8em; color: #777; white-space: nowrap;">${post.authorNickname || ''}</span>
                                            </div>
                                        </td>`;
                        tr.onclick = () => displayFullPostDetails(post.idx); 
                        postListTbodyEl.appendChild(tr);
                        if (post.idx === postToDisplayAutomatically) {
                            foundPostIdInList = true;
                        }
                    });

                    if (postToDisplayAutomatically && foundPostIdInList) {
                        await displayFullPostDetails(postToDisplayAutomatically); // await 추가
                    } else if (result.data.length > 0 && !postIdToSelect) {
                        await displayFullPostDetails(result.data[0].idx); // await 추가
                    } else if (postIdToSelect && !foundPostIdInList) {
                        console.warn(`Post with ID ${postIdToSelect} from URL not found in the fetched list.`);
                        clearPostDetailArea(true, `요청하신 게시글(ID:${postIdToSelect})을 찾을 수 없습니다.`);
                        toggleCommentForm(false); // 댓글 폼 비활성화
                    }
                }
            } else {
                throw new Error(result.message || "게시글 목록을 가져오는데 실패했습니다 (데이터 형식).");
            }
        } catch (error) {
            console.error("Error loading posts:", error);
            postListTbodyEl.innerHTML = `<tr><td colspan="1" style="text-align:center; color:red; padding:15px;">게시글 로드 오류.</td></tr>`;
            clearPostDetailArea(true, "게시글 로드 오류가 발생했습니다.");
            toggleCommentForm(false); // 댓글 폼 비활성화
        }
    }
    
    function clearPostDetailArea(showPlaceholder = false, placeholderText = "게시글을 선택해주세요.") {
        console.log(`[DEBUG] clearPostDetailArea 함수 호출됨. currentSelectedPostId가 null로 설정됩니다. Placeholder: ${showPlaceholder}, Text: ${placeholderText}`);
        console.log('[DEBUG] clearPostDetailArea 호출 스택:', new Error().stack);

        currentSelectedPostId = null;
        currentSelectedPostData = null;

        const postTitleEl = document.getElementById('wlb_postTitle');
        const postMetaEl = document.getElementById('wlb_postMeta');
        const postContentEl = document.getElementById('wlb_postContent');
        const postFilesEl = document.getElementById('wlb_postFiles');
        const commentListEl = document.getElementById('commentlist');
        const comcountEl = document.getElementById("comcount");
        const postActionButtonsEl = document.getElementById('wlb_postActionButtons');
        const commentTextarea = document.getElementById('mainCommentContent');
        const commentFileInput = document.getElementById('mainCommentFileUploadInput');
        const selectedCommentFilesDiv = document.getElementById('selectedMainCommentFilesList');


        if (postTitleEl) postTitleEl.textContent = showPlaceholder ? placeholderText : '로딩 중...';
        if (postMetaEl) postMetaEl.innerHTML = '';
        if (postContentEl) postContentEl.innerHTML = showPlaceholder ? '<p style="text-align:center; color:grey; margin-top:50px;">왼쪽 목록에서 게시글을 선택해주세요.</p>' : ''; 
        if (postFilesEl) postFilesEl.innerHTML = '';
        if (commentListEl) commentListEl.innerHTML = '<div style="text-align:center; color:grey; padding:10px;">댓글 정보가 없습니다.</div>';
        if (comcountEl) comcountEl.textContent = '0';
        if (postActionButtonsEl) postActionButtonsEl.style.display = 'none';
        
        // 댓글 폼 초기화
        if (commentTextarea) commentTextarea.value = '';
        if (commentFileInput) commentFileInput.value = ''; // 파일 입력 값 초기화
        if (selectedCommentFilesDiv) selectedCommentFilesDiv.innerHTML = ''; // 선택된 파일 목록 UI 초기화
        
        // 댓글 폼 비활성화 (게시글이 선택되지 않았으므로)
        if (showPlaceholder) { // 명시적으로 플레이스홀더를 보여줄 때만 댓글 폼 비활성화
            toggleCommentForm(false);
        }
    }

    async function displayFullPostDetails(postId) {
    console.log(`[DEBUG] Displaying full post details for postId: ${postId}`);

    // 1. 기존 게시글 상세 정보 영역을 먼저 초기화하고 "로딩 중..." 메시지를 표시합니다.
    //    이때 clearPostDetailArea 내부에서 currentSelectedPostId가 일시적으로 null이 됩니다.
    clearPostDetailArea(false);

    const postTitleEl = document.getElementById('wlb_postTitle');
    const postMetaEl = document.getElementById('wlb_postMeta');
    const postContentEl = document.getElementById('wlb_postContent');
    const postFilesEl = document.getElementById('wlb_postFiles');
    const postActionButtonsEl = document.getElementById('wlb_postActionButtons');
    const editPostBtn = document.getElementById('wlb_editPostBtn');
    const deletePostBtn = document.getElementById('wlb_deletePostBtn');

    if (!postTitleEl || !postMetaEl || !postContentEl || !postFilesEl || !postActionButtonsEl || !editPostBtn || !deletePostBtn) {
        console.error("[DEBUG] HTML elements for displaying post details are missing.");
        // toggleCommentForm(false); // clearPostDetailArea에서 이미 처리될 수 있음
        return;
    }

    try {
        // 2. 게시글 상세 정보를 API를 통해 가져옵니다.
        const response = await fetch(`/api/posts/${postId}`);
        console.log(`[DEBUG] API response status for /api/posts/${postId}: ${response.status}`);

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: "게시글 상세 정보를 가져오지 못했고, 오류 응답 본문 파싱에도 실패했습니다." }));
            console.error(`[DEBUG] API call failed for /api/posts/${postId}. Status: ${response.status}, Message: ${errorData.message}`);
            throw new Error(errorData.message || `Failed to fetch post details: ${response.status}`);
        }

        const result = await response.json();
        console.log(`[DEBUG] API result for /api/posts/${postId}:`, result);

        if (result.status === 200 && result.data) {
            const postDetail = result.data;

            // 3. API 호출이 성공하고 유효한 데이터를 받았을 때, 여기서 currentSelectedPostId와 currentSelectedPostData를 설정합니다!
            currentSelectedPostId = postId; // <<<< 중요! 여기서 postId로 설정
            currentSelectedPostData = postDetail;
            console.log(`[DEBUG] currentSelectedPostId is NOW definitively set to: ${currentSelectedPostId}`);

            // 4. 게시글 상세 내용을 화면에 표시합니다.
            postTitleEl.textContent = postDetail.title || "제목 없음";
            const postDate = new Date(postDetail.createdAt).toLocaleString('ko-KR', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: false });
            postMetaEl.innerHTML = `
                <div style="display: flex; align-items: center; gap: 5px;">
                    <img src="${postDetail.author && postDetail.author.profileImage ? postDetail.author.profileImage : '/icon/user2.png'}" style="height: 25px; width: 25px; border-radius:50%; object-fit:cover;"/>
                    <div style="font-size: 15px;">${postDetail.author ? postDetail.author.nickname : '작성자 정보 없음'}</div>
                </div>
                <div style="font-size: 12px; color:rgb(105, 105, 105); margin-left: auto;">${postDate}</div>`;

            postContentEl.innerHTML = postDetail.content || "<p>내용 없음</p>";

            postFilesEl.innerHTML = '';
            if (postDetail.files && postDetail.files.length > 0) {
                postDetail.files.forEach(file => {
                    const fileContainer = document.createElement('div');
                    fileContainer.style.marginBottom = '3px';
                    const fileLink = document.createElement('a');
                    fileLink.href = `/api/files/download/${file.idx}`;
                    const fileSizeMB = file.fileSize ? `(${(file.fileSize / 1024 / 1024).toFixed(2)} MB)` : '';
                    fileLink.textContent = `${file.fileName} ${fileSizeMB}`;
                    fileLink.style.cssText = 'font-size:small; color:#007bff; text-decoration:underline;';
                    fileLink.setAttribute('download', file.fileName);
                    fileLink.setAttribute('target', '_blank');

                    const fileIcon = document.createElement('img');
                    fileIcon.src = "/icon/link.png";
                    fileIcon.style.cssText = 'height:16px; width:16px; margin-right:4px; vertical-align:middle;';

                    fileContainer.appendChild(fileIcon);
                    fileContainer.appendChild(fileLink);
                    postFilesEl.appendChild(fileContainer);
                });
            } else {
                postFilesEl.innerHTML = '<span style="font-size:small; color:grey;">첨부된 파일이 없습니다.</span>';
            }

            postActionButtonsEl.style.display = 'flex';
            editPostBtn.onclick = () => editCurrentPost();
            deletePostBtn.onclick = () => deleteCurrentPost();

            // 5. 댓글을 로드하고 댓글 폼을 활성화합니다.
            await loadCommentsForPost(postId); // 이 함수는 이제 유효한 currentSelectedPostId를 참조할 수 있습니다.
            console.log(`[DEBUG] Post ${postId} details loaded successfully. Enabling comment form.`);
            toggleCommentForm(true);

        } else {
            // API 응답은 왔으나 status가 200이 아니거나 result.data가 없는 경우
            console.error(`[DEBUG] Failed to get valid data from API for post ${postId}. API Response Status: ${result.status}, Message: ${result.message}`);
            // 이 경우 currentSelectedPostId는 초기의 clearPostDetailArea 호출로 인해 null로 유지됩니다.
            clearPostDetailArea(true, `게시글(ID:${postId}) 정보를 가져오는데 실패했습니다 (서버 응답 오류).`);
            // toggleCommentForm(false)는 clearPostDetailArea 내부에서 호출됩니다.
        }
    } catch (error) {
        console.error(`[DEBUG] Error in displayFullPostDetails for postId ${postId}:`, error);
        // 오류 발생 시 currentSelectedPostId는 null로 유지됩니다.
        clearPostDetailArea(true, `게시글(ID:${postId}) 로드 중 오류가 발생했습니다.`);
        // toggleCommentForm(false)는 clearPostDetailArea 내부에서 호출됩니다.
    }
}

    async function loadCommentsForPost(postId) {
        console.log(`[DEBUG] loadCommentsForPost started for postId: ${postId}`);
        const commentListEl = document.getElementById('commentlist'); 
        const comcountEl = document.getElementById("comcount");     

        if (!commentListEl || !comcountEl) { console.error("Comment list or count element not found."); return; }
        commentListEl.innerHTML = '<div style="text-align:center; color:grey; padding:10px;">댓글 로딩 중...</div>';
        comcountEl.textContent = '0';

        try {
            const response = await fetch(`/api/posts/${postId}/comments`);
            console.log(`[DEBUG] Comments API response status for post ${postId}: ${response.status}`);
            if (!response.ok) {
                if (response.status === 401) { window.location.href = "/front/login.html"; return; }
                const errorData = await response.json().catch(() => ({message: "댓글을 가져오지 못했습니다."}));
                throw new Error(errorData.message || `Failed to fetch comments: ${response.status}`);
            }
            const result = await response.json(); 

            commentListEl.innerHTML = '';
            if (result.status === 200 && Array.isArray(result.data)) {
                let totalComments = 0;
                const countCommentsRecursively = (comments) => {
                    if (!comments) return;
                    comments.forEach(c => {
                        totalComments++;
                        if (c.childComments) countCommentsRecursively(c.childComments);
                    });
                };
                countCommentsRecursively(result.data);
                comcountEl.textContent = totalComments;

                if (result.data.length === 0) {
                    commentListEl.innerHTML = '<div style="padding:10px; text-align:center; color:grey;">댓글이 없습니다. 첫 댓글을 작성해보세요.</div>';
                } else {
                    result.data.forEach(comment => renderComment(comment, commentListEl, 0));
                }
                console.log(`[DEBUG] Comments successfully loaded and rendered for post ${postId}`);
            } else {
                throw new Error(result.message || "댓글 목록을 가져오는데 실패했습니다.");
                console.error(`[DEBUG] Failed to get valid comments for post ${postId}. API Status: ${result.status}, Message: ${result.message}`);
            }
        } catch (error) {
            console.error(`[DEBUG] Error in loadCommentsForPost for postId ${postId}:`, error);
            // 이 catch 블록에서 currentSelectedPostId를 변경하거나 toggleCommentForm(false)를 호출하는지 확인
            commentListEl.innerHTML = `<div style="text-align:center; color:red; padding:10px;">댓글 로드 오류.</div>`;
        }
        console.log(`[DEBUG] loadCommentsForPost finished for postId: ${postId}`);
    }
    
    async function addCommentHandler() {
        console.log("[DEBUG] addCommentHandler invoked. currentSelectedPostId at this moment:", currentSelectedPostId); // 이 로그를 추가!
        if (!currentSelectedPostId) {
            alert("댓글을 작성할 게시글을 먼저 선택해주세요.");
            return;
        }

        if (!currentSelectedPostId) {
            alert("댓글을 작성할 게시글을 먼저 선택해주세요."); // 이 alert이 발생하는지 확인
            return;
        }
        const commentInputElement = document.getElementById("mainCommentContent"); 
        const content = commentInputElement.value.trim();

        if (!content) {
            alert("댓글 내용을 입력해주세요.");
            commentInputElement.focus();
            return;
        }

        const commentData = { content: content, parentCommentId: null };

        try {
            const commentResponse = await fetch(`/api/posts/${currentSelectedPostId}/comments`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(commentData)
            });
            const commentResult = await commentResponse.json();

            if (!commentResponse.ok || !(commentResult.status === 201 && commentResult.data)) {
                throw new Error(commentResult.message || `댓글 작성 실패 (상태: ${commentResponse.status})`);
            }

            const savedCommentId = commentResult.data.commentIdx; 
            console.info("메인 댓글 내용 저장 성공. Comment ID:", savedCommentId);

            const mainCommentFileInput = document.getElementById('mainCommentFileUploadInput'); 
            const selectedMainCommentFilesListDiv = document.getElementById('selectedMainCommentFilesList'); 

            if (mainCommentFileInput && mainCommentFileInput.files.length > 0) {
                const formData = new FormData();
                let validFilesExist = false;
                for (const file of mainCommentFileInput.files) {
                    if (file.size > 10 * 1024 * 1024) { continue; }
                    formData.append('files', file);
                    validFilesExist = true;
                }

                if (validFilesExist) {
                    const filesUploadResponse = await fetch(
                        `/api/files/upload/multiple?referenceType=COMMENT&referenceIdx=${savedCommentId}`, 
                        { method: 'POST', body: formData }
                    );
                    if (!filesUploadResponse.ok) {
                        const filesErrorResult = await filesUploadResponse.json().catch(()=>({message: "댓글 파일 업로드 중 서버 오류"}));
                        alert(`댓글은 작성되었으나, 파일 업로드에 실패했습니다: ${filesErrorResult.message}`);
                    } else {
                        console.info("메인 댓글 파일 업로드 성공 for Comment ID:", savedCommentId);
                    }
                }
            }
            commentInputElement.value = "";
            if (mainCommentFileInput) mainCommentFileInput.value = ""; 
            if (selectedMainCommentFilesListDiv) selectedMainCommentFilesListDiv.innerHTML = ""; 
            
            await loadCommentsForPost(currentSelectedPostId);

        } catch (error) {
            console.error("Error creating main comment or uploading files:", error);
            alert(`댓글 처리 중 오류 발생: ${error.message}`);
        }
    }
    window.addCommentHandler = addCommentHandler;

    function addReply(parentCommentId, replyButtonElement, replySlotElement, depth) {
        // ... (이전 답변과 동일한 함수 내용 시작) ...
        document.querySelectorAll('.reply-form-container').forEach(form => form.remove());

        const replyFormContainer = document.createElement('div');
        replyFormContainer.className = 'reply-form-container';
        replyFormContainer.style.cssText = `margin-left: 0px; margin-top: 10px; padding: 10px; background-color: #f0f0f0; border: 1px solid #e0e0e0; border-radius: 5px;`;
        
        const uniqueIdSuffix = `_reply_${parentCommentId}_${new Date().getTime()}`;

        replyFormContainer.innerHTML = `
            <textarea class="reply-content-input" placeholder="답글 작성..." style="width: 100%; min-height: 50px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 0.9em;"></textarea>
            <div style="margin-top: 8px; margin-bottom: 8px;">
                <label for="replyFileUploadInput${uniqueIdSuffix}" style="font-size: 0.8em; color: #555; cursor:pointer;">
                    <img src="/icon/link.png" style="height:16px; width:16px; vertical-align: middle; margin-right: 3px;"/>
                    파일 첨부
                </label>
                <input type="file" id="replyFileUploadInput${uniqueIdSuffix}" class="reply-file-upload-input" multiple style="display: none;"/>
                <div class="selected-reply-files-list" style="font-size: 0.75em; color: #333; margin-top: 5px;"></div>
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 8px; margin-top: 8px;">
                <button class="submit-reply-button button_work2" style="font-size:0.85em; padding: 4px 8px; width:auto;">답글 등록</button>
                <button class="cancel-reply-button button_work2" style="background-color:#ddd; font-size:0.85em; padding: 4px 8px; width:auto;">취소</button>
            </div>
        `;
        
        replySlotElement.innerHTML = ''; 
        replySlotElement.appendChild(replyFormContainer);
        
        const replyContentInput = replyFormContainer.querySelector('.reply-content-input');
        const replyFileInput = replyFormContainer.querySelector(`#replyFileUploadInput${uniqueIdSuffix}`);
        const selectedReplyFilesDiv = replyFormContainer.querySelector('.selected-reply-files-list');
        const replyFileLabel = replyFormContainer.querySelector(`label[for="replyFileUploadInput${uniqueIdSuffix}"]`);
        const submitReplyButton = replyFormContainer.querySelector('.submit-reply-button');
        const cancelReplyButton = replyFormContainer.querySelector('.cancel-reply-button');

        if (replyFileLabel && replyFileInput) {
            // 수정: label의 for 속성으로 충분. 명시적 click() 제거
            // replyFileLabel.onclick = function() { replyFileInput.click(); }; 
            replyFileInput.addEventListener('change', function() {
                displaySelectedFiles(this.files, selectedReplyFilesDiv, `reply_${parentCommentId}_file_`);
            });
        }
        // ... (이전 답변과 동일한 함수 내용 끝 - submitReplyButton.onclick, cancelReplyButton.onclick 등) ...
        submitReplyButton.onclick = async () => {
            const content = replyContentInput.value.trim();
            if (!content) {
                alert('답글 내용을 입력하세요.');
                replyContentInput.focus();
                return;
            }
            const replyData = { content: content, parentCommentId: parentCommentId };
            try {
                const replyResponse = await fetch(`/api/posts/${currentSelectedPostId}/comments`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(replyData)
                });
                const replyResult = await replyResponse.json();
                if (!replyResponse.ok || !(replyResult.status === 201 && replyResult.data)) {
                    throw new Error(replyResult.message || `답글 작성 실패 (상태: ${replyResponse.status})`);
                }
                const savedReplyId = replyResult.data.commentIdx;
                console.info("대댓글 내용 저장 성공. Reply ID:", savedReplyId);

                if (replyFileInput && replyFileInput.files.length > 0) {
                    const formData = new FormData();
                    let validFilesExist = false;
                    for (const file of replyFileInput.files) {
                        if (file.size > 10 * 1024 * 1024) { continue; }
                        formData.append('files', file);
                        validFilesExist = true;
                    }
                    if (validFilesExist) {
                        const filesUploadResponse = await fetch(
                            `/api/files/upload/multiple?referenceType=COMMENT&referenceIdx=${savedReplyId}`, 
                            { method: 'POST', body: formData }
                        );
                        if (!filesUploadResponse.ok) {
                            const filesErrorResult = await filesUploadResponse.json().catch(()=>({message:"답글 파일 업로드 중 서버 오류"}));
                            alert(`답글은 작성되었으나, 파일 업로드에 실패했습니다: ${filesErrorResult.message}`);
                        } else {
                             console.info("대댓글 파일 업로드 성공 for Reply ID:", savedReplyId);
                        }
                    }
                }
                replyFormContainer.remove();
                await loadCommentsForPost(currentSelectedPostId);
            } catch (err) {
                console.error('Error creating reply or uploading files:', err);
                alert(`답글 처리 중 오류 발생: ${err.message}`);
            }
        };
        cancelReplyButton.onclick = () => { replyFormContainer.remove(); };
        replyContentInput.focus();
    }
    window.addReply = addReply;

    function renderComment(commentData, parentElement, depth) {
        // ... (이전 답변과 동일한 함수 내용) ...
        const commentDiv = document.createElement('div');
        commentDiv.className = depth === 0 ? 'commentlist-item' : 'commentlist-item-re'; 
        commentDiv.style.marginLeft = `${depth * 20}px`;
        
        const authorInfo = commentData.author; 
        const commentDate = new Date(commentData.createdAt).toLocaleString('ko-KR', {hour12: false, year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute:'2-digit' });

        let filesHTML = '';
        if (commentData.files && commentData.files.length > 0) { 
            filesHTML += `<div style="margin-left:${depth > 0 ? '0px' : '33px'}; margin-top:8px; font-size:0.85em;">`;
            commentData.files.forEach(file => {
                const fileSizeMB = file.fileSize ? (file.fileSize / (1024 * 1024)).toFixed(2) + ' MB' : '';
                filesHTML += `
                    <div style="margin-bottom: 3px; display:flex; align-items:center;">
                        <img src="/icon/link.png" style="height:14px; width:14px; margin-right:4px;"/>
                        <a href="/api/files/download/${file.idx}" target="_blank" download="${file.fileName}" style="color: #007bff; text-decoration:underline;">
                            ${file.fileName}
                        </a>
                        ${fileSizeMB ? `<span style="color:#777; font-size:0.9em; margin-left:5px;">(${fileSizeMB})</span>` : ''}
                    </div>`;
            });
            filesHTML += '</div>';
        }

        commentDiv.classList.add("replyArea");
        commentDiv.innerHTML = `
            <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 5px; padding-top: ${depth > 0 ? '8px' : '10px'};">
                <div style="display:flex; align-items:center;">
                    <img src="${authorInfo && authorInfo.profileImage ? authorInfo.profileImage : '/icon/user2.png'}" style="height: ${depth > 0 ? '22px' : '25px'}; width: ${depth > 0 ? '22px' : '25px'}; border-radius: 50%; margin-right: 8px; object-fit:cover;" />
                    <div style="font-size: ${depth > 0 ? '13px' : '14px'}; font-weight: bold;">${authorInfo ? authorInfo.nickname : '익명'}</div>
                </div>
                <div style="font-size: ${depth > 0 ? '10px' : '11px'}; color:rgb(105, 105, 105); margin-right:10px;">${commentDate}</div>
            </div>
            <div style="margin-left:${depth > 0 ? '30px' : '33px'}; margin-top:2px; margin-bottom: 8px;">
                <div style="font-size: ${depth > 0 ? '12px' : '13px'}; white-space:pre-wrap; word-break:break-all;">${commentData.content.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</div>
            </div>
            ${filesHTML}
            <div style="margin-left:${depth > 0 ? '30px' : '33px'}; display: flex; justify-content: space-between; align-items:center; margin-top: ${filesHTML ? '8px' : '0'};">
                <div class="comment-actions"></div>
                <button class="button_work" style="border-color:rgb(173, 98, 98); color:rgb(173, 98, 98); font-size:10px; height:18px; line-height:1; width:auto; padding:0 4px; margin-right: 10px;" onclick="deleteCommentHandler(${commentData.commentIdx})">삭제</button>
            </div>
            <!-- <div class="reply-form-slot" style="margin-left:${depth > 0 ? '30px' : '33px'};"></div> -->
            <div class="reply-form-slot"></div>
            <div class="reply-display-area" style="margin-left:${depth > 0 ? '0px' : '0px'}; background-color: rgb(247, 247, 247);"></div>
        `;
        
        const replyActionContainer = commentDiv.querySelector('.comment-actions');
        const replyFormSlot = commentDiv.querySelector('.reply-form-slot');
        const replyDisplayArea = commentDiv.querySelector('.reply-display-area');

        if (depth < 1) { // 예: 최상위 댓글에만 '답글쓰기' 버튼
            if (replyActionContainer) {
                const replyBtn = document.createElement('button');
                replyBtn.className = 'button_work';
                replyBtn.style.cssText = "font-size:10px; height:18px; line-height:1; width:auto; padding:0 4px; cursor:pointer;";
                replyBtn.textContent = '답글쓰기';
                replyBtn.onclick = (event) => {
                    event.stopPropagation(); 
                    addReply(commentData.commentIdx, replyBtn, replyFormSlot, depth + 1);
                };
                replyActionContainer.appendChild(replyBtn);
            }
            commentDiv.classList.remove("replyArea");
        }
        parentElement.appendChild(commentDiv);
        
        if (depth === 0 && parentElement.lastChild && parentElement.lastChild.style) {
            parentElement.lastChild.style.borderBottom="none";
            if (parentElement.lastChild.previousSibling && parentElement.lastChild.previousSibling.style) {
                parentElement.lastChild.previousSibling.style.borderBottom = "1px solid rgb(235, 235, 235)";
            }
        } else if (depth > 0 && parentElement.lastChild && parentElement.lastChild.style) {
             parentElement.lastChild.style.borderBottom="none";
             if (parentElement.lastChild.previousSibling && parentElement.lastChild.previousSibling.style) {
                parentElement.lastChild.previousSibling.style.borderBottom = "1px solid #f1f1f1";
            }
        }

        if (commentData.childComments && commentData.childComments.length > 0) {
            commentData.childComments.forEach(child => renderComment(child, replyDisplayArea, depth + 1));
        }
    }

    async function deleteCommentHandler(commentId) { 
        // ... (이전 답변과 동일한 함수 내용) ...
        if (!commentId || !confirm("이 댓글을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.\n(대댓글과 첨부파일도 함께 삭제됩니다.)")) return;
        try {
            const response = await fetch(`/api/comments/${commentId}`, { method: 'DELETE' });
            if (response.status === 200 || response.status === 204 || response.ok) { 
                alert("댓글이 삭제되었습니다.");
                await loadCommentsForPost(currentSelectedPostId); 
            } else {
                const result = await response.json().catch(()=>({message:"알 수 없는 오류로 삭제에 실패했습니다."}));
                throw new Error(result.message || `댓글 삭제 실패 (상태: ${response.status})`);
            }
        } catch (error) {
            console.error("Error deleting comment:", error);
            alert(`댓글 삭제 중 오류 발생: ${error.message}`);
        }
    }
    window.deleteCommentHandler = deleteCommentHandler;

    function updateWorklistBoardButtonLinks(taskId, projectId) {
        // ... (이전 답변과 동일한 함수 내용) ...
        const writePostBtn = document.getElementById('wlb_writePostBtn'); 
        if (writePostBtn && taskId != null && projectId != null) {
            writePostBtn.onclick = () => {
                window.location.href = `writework.html?taskId=${taskId}&projectId=${projectId}`;
            };
        }

        const goBackBtn = document.getElementById('wlb_goBackBtn'); 
        if (goBackBtn && projectId != null) {
            goBackBtn.onclick = () => {
                window.location.href = `projectboard.html?projectId=${projectId}`;
            };
        }
    }

    function editCurrentPost() { 
        // ... (이전 답변과 동일한 함수 내용) ...
        if (currentSelectedPostId && currentSelectedPostData && currentWlbProjectId != null) {
            const actualTaskId = currentSelectedPostData.taskId || currentWlbTaskId; 
            window.location.href = `writework.html?postId=${currentSelectedPostId}&taskId=${actualTaskId}&projectId=${currentWlbProjectId}`;
        } else {
            alert("수정할 게시글 정보가 충분하지 않습니다. 게시글을 선택했는지 확인해주세요.");
        }
    }
    window.editCurrentPost = editCurrentPost;

    async function deleteCurrentPost() { 
        // ... (이전 답변과 동일한 함수 내용) ...
        if (!currentSelectedPostId || !currentSelectedPostData) {
            alert("삭제할 게시글이 선택되지 않았습니다.");
            return;
        }
        const postTitleForConfirm = currentSelectedPostData.title || "이";
        const userConfirm = confirm(`'${postTitleForConfirm}' 게시글을 정말 삭제하시겠습니까?\n이 작업은 되돌릴 수 없으며, 게시글의 모든 댓글과 첨부파일도 함께 삭제됩니다.`);
        if (!userConfirm) return;

        try {
            const response = await fetch(`/api/posts/${currentSelectedPostId}`, { method: 'DELETE' });
            if (response.status === 204 || (response.ok && response.headers.get("content-length") === "0") ) { 
               alert("게시글이 성공적으로 삭제되었습니다.");
               clearPostDetailArea(true, "게시글이 삭제되었습니다. 목록에서 다른 게시글을 선택해주세요."); 
               loadPostsForBoard(currentWlbTaskId); 
            } else if (response.ok) { 
                const result = await response.json();
                alert(result.message || "게시글이 성공적으로 삭제되었습니다.");
                clearPostDetailArea(true, "게시글이 삭제되었습니다. 목록에서 다른 게시글을 선택해주세요.");
                loadPostsForBoard(currentWlbTaskId);
            } else {
               const result = await response.json().catch(()=>({message:"알 수 없는 오류로 삭제에 실패했습니다."}));
               throw new Error(result.message || `게시글 삭제 실패 (상태: ${response.status})`);
            }
        } catch (error) {
            console.error("Error deleting post:", error);
            alert(`게시글 삭제 중 오류 발생: ${error.message}`);
        }
    }
    window.deleteCurrentPost = deleteCurrentPost;
</script>
</html>